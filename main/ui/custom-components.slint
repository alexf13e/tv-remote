
import { Button } from "std-widgets.slint";
import { RemoteButtonData } from "custom-component-data.slint";
import { RemoteScreenID, CurrentDisplayedScreen } from "remote-screens-index.slint";
import { Symbols } from "symbols.slint";


export global Logic { //container for functions to interact with c++ from gui
    pure callback remote_btn_clicked(string);
    pure callback sleep();
}


export component RemoteButton { //custom button for sending remote signals and navigating the ui
    in property <image> icon;                                   //image to show on button
    in property <string> text;                                  //text to show on button
    in property <length> fontSize;
    in property <string> actionListID: "";                      //name of the "macro" to play when button is pressed
    in property <RemoteScreenID> screenID: RemoteScreenID.SAME; //the id of the screen which will be shown when this button is clicked

    Rectangle { //rectangle for the whole button shape
        background: white;

        Image { //image to display button icon
            width: root.width;
            height: root.height;
            image-fit: contain;
            source: icon;
        }

        Text {
            text: text;
            font-size: fontSize;
            wrap: word-wrap;
        }

        if touch.pressed: Rectangle { //when the button is pressed, shade it darker for visual feedback
            background: #0000007f;
        }
        
        touch := TouchArea { //toucharea to detect when the button is being pressed
            pointer-event(event) => {
                if (event.kind == PointerEventKind.up) {
                    Logic.remote_btn_clicked(root.actionListID);
                    CurrentDisplayedScreen.set(root.screenID);
                }
            }
        }
    }
}


export component NavPanel { //panel with bottom navigation buttons to replicate pronto layout
    in property <string> txt_btn1: "btn1"; //text to display on 4 main buttons
    in property <string> txt_btn2: "btn2";
    in property <string> txt_btn3: "btn3";
    in property <string> txt_btn4: "btn4";

    in property <string> al_btn1; //action list id to run when each button is pressed
    in property <string> al_btn2;
    in property <string> al_btn3;
    in property <string> al_btn4;

    in property <RemoteScreenID> screen_btn1; //screen id to change to when each button is pressed
    in property <RemoteScreenID> screen_btn2;
    in property <RemoteScreenID> screen_btn3;
    in property <RemoteScreenID> screen_btn4;

    in property <string> al_navLeft; //action list id for nav buttons (e.g. for tv or recording box)
    in property <string> al_navRight;
    in property <string> al_navUp;
    in property <string> al_navDown;
    in property <string> al_ok;
    in property <string> al_return;
    
    VerticalLayout {
        spacing: 10px;

        HorizontalLayout {
            spacing: parent.spacing;
            height: 50px;

            RemoteButton {
                height: parent.height;
                horizontal-stretch: 0;
                text: txt_btn1;
                actionListID: al_btn1;
                screenID: screen_btn1;
            }

            RemoteButton {
                height: parent.height;
                horizontal-stretch: 0;
                text: txt_btn2;
                actionListID: al_btn2;
                screenID: screen_btn2;
            }

            RemoteButton {
                height: parent.height;
                horizontal-stretch: 0;
                text: txt_btn3;
                actionListID: al_btn3;
                screenID: screen_btn3;
            }

            RemoteButton {
                height: parent.height;
                horizontal-stretch: 0;
                text: txt_btn4;
                actionListID: al_btn4;
                screenID: screen_btn4;
            }
        }

        GridLayout {
            spacing: parent.spacing;

            RemoteButton {
                row: 0;
                col: 1;
                icon: Symbols.arrow-up;
                actionListID: al_navUp;
            }

            RemoteButton {
                row: 1;
                col: 0;
                icon: Symbols.arrow-left;
                actionListID: al_navLeft;
            }

            RemoteButton {
                row: 1;
                col: 1;
                text: "Ok";
                actionListID: al_ok;
            }

            RemoteButton {
                row: 1;
                col: 2;
                icon: Symbols.arrow-right;
                actionListID: al_navRight;
            }

            RemoteButton {
                row: 2;
                col: 0;
                text: "Return";
                actionListID: al_return;
            }

            RemoteButton {
                row: 2;
                col: 1;
                icon: Symbols.arrow-down;
                actionListID: al_navDown;
            }

            RemoteButton {
                row: 2;
                col: 2;
                icon: Symbols.home;
                screenID: RemoteScreenID.HOME;
            }
        }
    }
}


export component VolumePanel {
    in property <string> al_chanUp;
    in property <string> al_chanDown;
    in property <string> al_volMute;
    in property <string> al_volUp;
    in property <string> al_volDown;

    VerticalLayout {
        spacing: 5px;

        RemoteButton {
            text: "chan+";
            actionListID: al_chanUp;
        }

        RemoteButton {
            text: "chan-";
            actionListID: al_chanDown;
        }

        RemoteButton {
            text: "mute";
            actionListID: al_volMute;
        }

        RemoteButton {
            text: "vol+";
            actionListID: al_volUp;
        }

        RemoteButton {
            text: "vol-";
            actionListID: al_volDown;
        }
    }
}


export component ScreenTemplate { //template for screens mimicking pronto physical button layout  
    
    //properties to specify what the nav and volume buttons should do, with sensible defaults
    //action list names for the volume and change channel buttons
    in property <string> volume_panel_al_chan_up: "TV_CHAN_UP";
    in property <string> volume_panel_al_chan_down: "TV_CHAN_DOWN";
    in property <string> volume_panel_al_mute: "SPEAKERS_MUTE";
    in property <string> volume_panel_al_vol_up: "SPEAKERS_VOL_UP";
    in property <string> volume_panel_al_vol_down: "SPEAKERS_VOL_DOWN";

    //text to display on the row of 4 buttons
    in property <string> nav_panel_txt_btn_1: "Speakers";
    in property <string> nav_panel_txt_btn_2: "TV";
    in property <string> nav_panel_txt_btn_3: "HDD";
    in property <string> nav_panel_txt_btn_4: "YouView";

    //action lists to run when the row of 4 buttons are pressed
    in property <string> nav_panel_al_btn_1: "SPEAKERS_POWER";
    in property <string> nav_panel_al_btn_2: "TV_POWER";
    in property <string> nav_panel_al_btn_3: "HDD_POWER";
    in property <string> nav_panel_al_btn_4: "";

    //action lists to run when directional buttons are pressed
    in property <string> nav_panel_al_navLeft: "TV_NAV_LEFT";
    in property <string> nav_panel_al_navRight: "TV_NAV_RIGHT";
    in property <string> nav_panel_al_navUp: "TV_NAV_UP";
    in property <string> nav_panel_al_navDown: "TV_NAV_DOWN";
    in property <string> nav_panel_al_ok: "TV_OK";
    in property <string> nav_panel_al_return: "TV_RETURN";

    preferred-width: 100%;
    preferred-height: 100%;


    VerticalLayout { //container for whole screen
        spacing: 50px;

        HorizontalLayout { //container for main page content and volume/channel buttons
            spacing: 10px;

            @children //screen-specific content will be placed here
            
            VolumePanel { //display vertical column with volume and channel controls
                max-width: 50px;
                al_chanUp: volume_panel_al_chan_up;
                al_chanDown: volume_panel_al_chan_down;
                al_volMute: volume_panel_al_mute;
                al_volUp: volume_panel_al_vol_up;
                al_volDown: volume_panel_al_vol_down;
            }
        }

        NavPanel { //show a set of buttons at the bottom of the screen (e.g. directional, ok/back, home)
            height: 300px;
            
            txt_btn1: nav_panel_txt_btn_1;
            txt_btn2: nav_panel_txt_btn_2;
            txt_btn3: nav_panel_txt_btn_3;
            txt_btn4: nav_panel_txt_btn_4;

            al_btn1: nav_panel_al_btn_1;
            al_btn2: nav_panel_al_btn_2;
            al_btn3: nav_panel_al_btn_3;
            al_btn4: nav_panel_al_btn_4;

            al_navLeft: nav_panel_al_navLeft;
            al_navRight: nav_panel_al_navRight;
            al_navUp: nav_panel_al_navUp;
            al_navDown: nav_panel_al_navDown;
            al_ok: nav_panel_al_ok;
            al_return: nav_panel_al_return;
        }
    }
}


component GridPage {
    in property <int> num_cols; //how many rows and columns of buttons to fit within a sub screen
    in property <int> num_rows;
    in property <length> button_width; //how big the buttons should be
    in property <length> button_height;

    //load the list of button data (icons, actio macro names)
    in property <[RemoteButtonData]> gridData;
        
    //determine the range of button indices to display based on sub screen
    out property <int> currentSubScreen: 0;
    property <int> iMin: currentSubScreen * num_cols * num_rows;
    property <int> iMax: min(iMin + num_cols * num_rows, gridData.length);
    
    //calculate spacing between buttons manually, cannot use grid with for loop
    property <length> horizontal_spacing: (self.width - num_cols * button_width) / (num_cols - 1);
    property <length> vertical_spacing: (self.height - num_rows * button_height) / (num_rows - 1);

    callback setSubScreen(int);
    setSubScreen(subScreen) => {
        currentSubScreen = subScreen;
        iMin = currentSubScreen * num_cols * num_rows;
        iMax = min(iMin + num_cols * num_rows, gridData.length);
    }


    for i in (iMax - iMin):
    RemoteButton {
        x: floor(i / num_rows) * (button_width + horizontal_spacing);
        y: mod(i, num_rows) * (button_height + vertical_spacing);
        width: button_width;
        height: button_height;

        icon: gridData[i + iMin].icon;
        text: gridData[i + iMin].text;
        actionListID: gridData[i + iMin].actionListID;
    }
}

export component MultiPageRemoteButtonGrid { //automatically populated grid spanning multiple pages
    //properties for creating the grid page, to be passed in to it
    in property <int> num_cols;
    in property <int> num_rows;
    in property <length> button_width;
    in property <length> button_height;
    in property <[RemoteButtonData]> gridData;

    property <int> numSubScreens: ceil(gridData.length / (num_cols * num_rows)); //how many sub screens of buttons

    callback setSubScreen(int);
    setSubScreen(subScreen) => {
        gridPage.setSubScreen(subScreen);
    }


    //display buttons for this sub screen
    VerticalLayout {
        //must create grid page as separate component to allow specific positioning of generated elements within vertical layout
        //generated elements cannot use grid layout
        gridPage := GridPage {
            num_cols: num_cols;
            num_rows: num_rows;
            button_width: button_width;
            button_height: button_height;
            gridData: gridData;
        }

        HorizontalLayout { //navigation buttons between sub screens
            padding-top: 10px;
            if numSubScreens > 1:
            Button {
                icon: Symbols.arrow-left;
                clicked => {
                    if gridPage.currentSubScreen > 0 {
                        setSubScreen(gridPage.currentSubScreen - 1);
                    }
                }
            }

            Text {
                text: gridPage.currentSubScreen + 1 + "/" + numSubScreens;
                vertical-alignment: center;
                horizontal-alignment: center;
                color: white;
            }

            if numSubScreens > 1:
            Button {
                icon: Symbols.arrow-right;
                clicked => {
                    if gridPage.currentSubScreen < numSubScreens - 1 {
                        setSubScreen(gridPage.currentSubScreen + 1);
                    }
                }
            }
        }
    }
}